# 小程序实现原理

> 两个特点：
>
> 1. 免安装
> 2. 具备通过宿主APP访问原生OS的能力



![新的双线程架构](https://camo.githubusercontent.com/01738dc6d9f3cf8ebf4c4a5204b663bc3d464c9b/68747470733a2f2f73332e73736c2e71687265732e636f6d2f7374617469632f383630373864333433363739623763382e737667)

## 双线程

小程序是采用双线程的架构方式，一个是逻辑层，这一层主要是处理JS的逻辑代码，实际上是一个“Web Worker”的存在，另一个是UI层，这一层主要是渲染和展示实际的页面。

通过web worker可以来调用一些移动端原生的API来实现一些性能的提升和优化，给到小程序调用Native的能力。由于在移动端小程序一次只会有一个小程序是打开的，所以在web worker中主要是对一个小程序做维护，这里主要是执行JS代码和对数据处理。

UI层主要是存放了用户的模版代码和公用的组件代码，以及类似浏览器的一些DOM的API，由于双线程的设计，防止用户之间使用一些API来控制页面，所以小程序会对一些API做屏蔽，通过AMD的方式来屏蔽（document这样的对象）

![多线程](https://camo.githubusercontent.com/c13dcd481b683390ae3c5f57b64538d57c5847d4/687474703a2f2f71696e69752e626b742e64656d6f732e736f2f2545352541342539412545372542412542462545372541382538422e706e67)

UI层本身是多线程的，可以理解在UI层是一个多页应用，只是在逻辑层通过路由来控制页面的切换，这里肯定存在页面的缓存问题，以及路由前进后退的问题。所以这里也就能理解为什么微信小程序官方会限制嵌套页面的深度。

组件在小程序中的初始化是有两次的，一次是在逻辑层中的初始化，另一次是通信到UI层的初始化。

##### 生命周期

![生命周期流程图-全部流程](https://camo.githubusercontent.com/044d82cfb8af0e088cad85c96c7d328147b28c51/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f544231716e4f367a344431674b306a535a4679585863694f5658612d3536302d3530362e737667)

小程序的生命周期，由于涉及到双线程的设计，所以整个完整的生命周期就是从代码到实际页面渲染的过程。

1. UI层初始化，创建基础组件
2. UI层通知逻辑层，开始创建组件
3. 逻辑层创建组件前的处理（对组件的初始化和数据初始化）
4. 逻辑层创建组件
5. 逻辑层将组件传输到UI层进行首次渲染
6. UI层渲染结束后，通知逻辑层UI层已经准备好（这里主要是对基础组件和模版的渲染）
7. 逻辑层处理业务数据，将数据更新到UI层，完成页面的更新
8. UI层触发事件，通知到逻辑层触发数据的处理



在UI层触发事件，需要通过异步通信的方式才能到达逻辑层，这里在通信成本上是更高了的，对于实际的频繁交互是会有影响的。底层可能是通过压缩通信数据的方式来提升性能的，例如使用JSON。



---

Link：

[小程序底层实现原理及一些思考-1](https://github.com/berwin/Blog/issues/43)

[小程序底层实现原理及一些思考-2](https://github.com/berwin/Blog/issues/49)