# HTTP / 2

## 为什么使用HTTP/2？

> HTTP/2的唯一目标是改进性能！

保留了HTTP的明文协议，或者是HTTPS的加密协议

### 第一个改进：头部压缩 HPACK

> 在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用**哈夫曼编码**来压缩整数和字符串，可以达到 50%~90% 的高压缩率。

### 第二个改进：二进制格式

> 原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用**复杂的状态机**，效率低，还麻烦。（HTTP/1 的问题所在，复杂的处理标准）
>
> 而二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。

### 第三个改进：流

> - HTTP/2 定义了一个流（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流ID。
> - 这样便能够在流的基础上，发送多个“碎片化”的消息，也就是**“多路复用”**——多个往返通信都服用一个连接来处理。
> - HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“**服务器推送**”（Server Push，也叫 Cache Push）。

### 安全方面

浏览器支持的HTTP/2 都是基于加密的，都是基于TLS的HTTP/2协议。

协议中的两个字符串标识符：

- “h2”表示加密的HTTP/2
- “h2c”表示明文的HTTP/2

### 协议栈

![img](https://static001.geekbang.org/resource/image/83/1a/83c9f0ecad361ba8ef8f3b73d6872f1a.png)

## HTTP/2 核心

![img](https://static001.geekbang.org/resource/image/89/17/8903a45c632b64c220299d5bc64ef717.png)

### 连接前言

> `Magic: PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n`
>
> 服务器收到这个“有魔力的字符串”，就知道客户端在 TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2 的数据格式。

### 头部压缩

> **“HPACK”算法**是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。

将原来的HTTP的头字段通过一个表来管理，映射都对应的二进制的数据上：

![img](https://static001.geekbang.org/resource/image/76/0c/769dcf953ddafc4573a0b4c3f0321f0c.png)

> **伪头字段**（pseudo-header field）：不是头字段的字段，为了和原有的HTTP头字段区分，在头字段名称之前添加`:`来区分。
>
> 上图是**“静态表”**的一部分，还有一部分是根据服务器和客户端请求定制的，这部分维护在**动态表**里面。

通过在两端之前维护一张表，将原本冗长的头字段，变成了简单的数字来处理，这样在网络中传输的效率就提上来了。



### 二进制帧

![img](https://static001.geekbang.org/resource/image/61/e3/615b49f9d13de718a34b9b98359066e3.png)

不同的二进制帧位置对应的数据含义不同：

- 帧长度：通过3字节来表示
- 帧类型：1字节表示，
- 标志位：1字节表示，
- 帧标志：相当于HTTP/1中的空行
- 流标识符：帧在流中的位置，通过ID来拼接成一个对应的流



### 多路复用

> 流：二进制帧的双向传输序列

流的关键是ID，在HTTP/2中，通过相同的ID来识别是同一个“请求-应答”，收到对应的数据之后在拼接起来。

#### 流的特点：

1. **流是可并发的，一个HTTP/2连接上可以同时发出多个流传输数据，也就是并发多请求，实现多路复用**。
2. 客户端和服务端都可以创建流，双方互不干扰；
3. 流是双向的，一个流里面客户端和服务端都可以发送或者接收数据帧，也就是一个“请求-应答”来回；
4. 流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；
5. 流可以设置优先级，让服务器先处理，比如先传HTML/CSS，后传图片，优化用户体验；
6. 流ID不能重用，只能顺序递增，**客户端发起的ID是奇数，服务端发起的ID是偶数**；
7. 在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；
8. 第0号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用户流量控制。

![根据流ID重组流](https://static001.geekbang.org/resource/image/b4/7e/b49595a5a425c0e67d46ee17cc212e7e.png)

上图描述了如何通过流ID重组流。



- HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。



#### 流状态转换

![img](https://static001.geekbang.org/resource/image/d3/b4/d389ac436d8100406a4a488a69563cb4.png)

1. idle：空闲
2. open：打开，在客户端发送 HEADERS帧之后
3. half closed：半关闭，客户端发送 END_STREAM 帧之后
4. close：关闭，服务端发送响应数据之后，在half closed的情况下带上 END_STREAM帧。流结束。

### 小结

> 1. HTTP/2 必须先发送一个“连接前言”字符串，然后才能建立正式连接；
> 2. HTTP/2 废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；
> 3. HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；
> 4. 流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；
> 5. 在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。